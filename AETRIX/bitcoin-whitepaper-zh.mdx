---
title: '比特币：一种点对点的电子现金系统（中文）'
description: '中本聪原版比特币白皮书的中文翻译，包含完整章节、公式与参考文献'
icon: 'bitcoin'
---

# 比特币：一种点对点的电子现金系统

**中本聪**  
satoshin@gmx.com  
www.bitcoin.org

**摘要**

一种纯粹的点对点版本的电子现金，将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名提供了部分解决方案，但如果仍然需要受信任的第三方来防止双重支付，那么其主要好处将丢失。我们需要一个点对点的解决方案，用于防止双重支付。该方案通过利用点对点网络来标记交易的时间，将它们散列到正在进行的基于工作量证明的链中，形成一个记录，该记录除非重新完成工作量证明，否则无法更改。最长的链条不仅证明了事件序列，而且证明了它来自最大的CPU功率池。只要大多数CPU功率由不打算攻击网络的节点控制，他们将产生最长的链条，并领先于攻击者。网络本身只需要极少的结构。消息以最佳方式广播，节点可以随时离开和重新加入网络，接受最长的工作量证明链条作为在他们离开期间发生事情的证明。

## 1. 引言

互联网上的商业已经几乎完全依赖于作为可信任第三方的金融机构来处理电子支付。虽然这种系统对于大多数交易都能很好地工作，但它仍然存在基于信任模型的固有弱点。金融中介机构的必要性增加了交易成本，并限制了最小可能的交易规模，从而阻碍了小型随意支付的可能性。并且无法进行不可撤销的支付服务，因为金融机构无法避免调解纠纷。通过调解，商家在诚信方面需要客户信任，并且对客户的信任（反过来）也需要商家在某些程度上信任。处理数字商品的非撤销支付是尤其困难的，因为它没有物理副本并且不需要亲自交付。需要一种基于密码学的电子支付系统，而非信任；允许任意两方直接交易，而无需受信任的第三方参与。不可撤销性对于那些想要进行非可逆交易的服务提供商来说是必要的，对于那些想要免受撤销交易的服务来说也是必要的。这个系统中，通过工作量证明[3]而不是信任来解决双重支付问题。我们提出一个使用点对点网络的时间戳服务器[2]来证明交易的顺序的解决方案，通过将它们散列到一个持续增长的、基于工作量证明的哈希链中，以构成除了重新进行工作量证明之外无法更改的记录。最长的链条证明了大部分的CPU计算力。如果大多数CPU计算力由没有动机攻击网络的节点控制，它们将产生最长的链条，并超过攻击者。

## 2. 交易

我们定义一个电子币为数字签名的链。每个所有者通过将其哈希与前一个交易的哈希和下一个所有者的公钥进行签名，将币转移给下一个所有者，并将这些连接到链条中。收款人可以通过验证签名来验证所有权链。

> 签名(交易) -> 哈希(交易) -> 下一个所有者公钥 -> 签名(交易) -> ...

问题是收款人无法验证之前的所有者是否从未对同一币进行了双重支付。常见的解决方案是引入一个可信任的中心权威，或者铸币厂，检查每一笔交易是否有双重支付。在每一笔交易后，铸币厂收集所有交易并决定哪些是第一次发生的。唯一必须由铸币厂发行新币的方式，是每次交易都需要铸币厂铸造并收回旧币。

为了在没有信任的情况下实现，需要公开宣布所有交易，并且需要一个系统，以便所有参与者都能就交易的顺序达成一致。付款人需要证明他拥有该币在一个特定的时间点，并且在该时间点之后没有将它转移给任何人。这可以通过公共时间戳服务器来实现。点对点网络中的每个节点都有一个时间戳服务器，它通过将交易的哈希添加到哈希中，生成一个时间戳，并将该哈希广播给其他节点。这些节点将该哈希添加到下一个区块中。

## 3. 时间戳服务器

网络中的每个节点运行一个时间戳服务器。为了实现这一点，我们使用点对点网络构建一个时间戳服务器。它通过对要加时间戳的项目集合进行哈希处理，并将结果广播到网络中来工作[2]。时间戳证明了数据在时间戳存在时的存在，因为哈希已经包含在哈希中。每个时间戳在其哈希中包含前一个时间戳，从而形成一个链条，每个新的时间戳都加强了之前的时间戳。

> 时间戳1 -> 哈希 -> 时间戳2 -> 哈希 -> ...

## 4. 工作量证明

为了在点对点基础之上实现时间戳服务器，我们使用工作量证明系统，类似于Hashcash [3]。我们通过查找一个哈希值来在哈希中实现工作量证明，该哈希值以许多零位开头。CPU平均需要进行的工作量与所需零位数量成指数关系，并且可以由任何了解哈希的人轻松验证。

对于我们的时间戳网络，我们将交易集合的哈希放入工作量证明中。我们将区块的哈希值（包括时间戳和前一个区块的哈希）与随机数（nonce）进行哈希运算，直到找到一个以所需数量的零开头的值。一旦找到了符合要求的哈希，我们就将这个区块广播到网络中。这个区块成为链中的下一个区块。

> 区块(时间戳, 前一个哈希, 交易集合) -> 哈希(区块, nonce) -> 需要以零开头的哈希

为了在不更改区块哈希的情况下修改区块，攻击者将需要重新完成该区块及其所有后续区块的工作量证明。随着后续区块被添加，改变区块的难度呈指数级增长。

工作量证明也解决了如何确定在多数投票时，网络中"一CPU一票"的投票问题。如果多数是基于IP地址的，那么任何能够分配大量IP地址的人都可以破坏它。工作量证明的本质是，一个CPU通常等于一票。多数决定由最长的链条表示，因为它包含最多的工作量证明。如果大多数CPU计算力由诚实的节点控制，最诚实的链条将增长最快，并超过任何竞争的链条。为了修改过去的区块，攻击者需要重新计算该区块和其后的所有区块的工作量证明，然后赶上并超过诚实节点的链条。我们稍后会证明，随着时间的推移，这种情况的可能性会呈指数级降低。

## 5. 网络

运行网络的步骤如下：
1. 新的交易被广播到所有节点。
2. 每个节点将新的交易收集到一个区块中。
3. 每个节点尝试为其区块找到一个困难的工作量证明。
4. 当一个节点找到了一个工作量证明，它将区块广播给所有节点。
5. 节点只有在区块中的所有交易都有效且尚未花费的情况下，才接受该区块。
6. 节点通过使用区块的哈希作为下一个区块的先前哈希来表示接受该区块。

节点总是考虑最长链条作为正确链条，并努力扩展它。如果两个节点同时广播了不同版本的下一个区块，一些节点可能会先收到其中一个。在这种情况下，它们在收到的第一个区块上工作，但保留另一个分支。当下一个工作量证明找到后，情况变得明朗，节点切换到更长链条并放弃另一个分支。

新的交易广播不需要到达所有节点。只要它们到达足够的节点，以便在合理的时间内被包含在区块中。广播的区块也是容忍丢失消息的。如果一个节点没有收到特定的区块，当它收到下一个区块时，它会意识到自己丢失了一个区块，并请求该区块。

## 6. 激励

按照惯例，区块中的第一个交易是一个特殊的交易，它由创建区块的节点发起，并创建一个新的币。这给节点一个激励来支持网络，并提供一种将新币分配到流通中的方式，因为中心机构无法做到这一点。新币的持续加入类似于金矿矿工花费CPU时间来挖金子。

激励也可以是通过交易费用。如果输出值小于输入值，则差额是添加到包含交易的区块的节点的交易费用。一旦预定数量的币进入流通，激励就可以完全转换为交易费用，并且可以完全放弃通货膨胀。

激励机制有助于鼓励节点保持诚实。如果一个贪婪的攻击者能够聚集比所有诚实节点更多的CPU能力，他将不得不在窃取其付款和使用其CPU能力生成新币之间进行选择。他应该发现，通过诚实地玩规则并生成更多的币比通过非诚实活动颠覆系统对他更有利。因为他必须遵守规则以生成自己的币，而这些币的价值将取决于系统的有效性。

## 7. 回收磁盘空间

一旦区块中的最新交易被花费，包含该交易的区块就不再需要保存在本地以验证未来的交易。为了在不破坏区块哈希的情况下使区块可回收，我们可以使用梅克尔树[4][5]将交易哈希组成一个树，只将根哈希包含在区块的哈希中。旧区块可以通过截断树的旧部分来压缩。内部哈希不需要存储。

> 根哈希 -> 哈希 -> 哈希 -> 交易

一个没有交易的区块头只有80字节。如果我们将块率设定为每10分钟一个区块，每年将有80字节 * 6 * 24 * 365 = 4.2MB。在1000美元的PC上，即使磁盘空间成为问题，也可以通过削减旧区块来卸载整个区块链。为了验证一个交易没有被双重支付，历史记录必须被扫描以寻找花费它的交易。如果旧交易被削减，该过程将无法实现。为了证明旧交易仍然未被花费，我们可以保留梅克尔树的叶子节点哈希。

## 8. 简化的支付验证

无需运行完整的网络节点即可验证支付。一个用户只需要一个区块链的头副本，他可以通过查询网络节点来获取最长链条，并获得指向交易的梅克尔分支以证明它被链接到一个区块。他不能自己验证交易，但通过将其链接到工作量证明链条中的一个位置，他可以看到一个网络节点已经接受了它，并且那些在链条后添加了区块的网络节点也接受了它。

> 用户 -> 交易 -> 网络节点 -> 区块 -> 梅克尔分支

只要诚实的节点控制网络，验证就是可靠的。但是，如果网络被攻击者控制，验证可能会受到攻击者的欺骗。虽然可以构建任意交易，但攻击者不能在不知道该交易的无效交易（双重支付）的情况下在梅克尔树中隐藏它。当欺骗的区块广播时，用户的软件应该通过请求完整区块并检查不一致性来检测它。

## 9. 合并与分割价值

虽然可以将单个币作为单独的输入处理，但如果交易包含多个输入和输出，则会笨拙。为了允许价值分割和合并，交易将包含多个输入和输出。通常，将有一个输入来自较大的先前交易或多个来自较小金额的输入，以及最多两个输出：一个用于支付，一个用于将找零返回给发送者（如果需要）。

请注意，一个交易可能依赖于几个输入，而这些输入又依赖于许多先前的交易，依此类推。但是，我们不需要获取所有完整的历史记录来验证某个交易没有被双重支付。历史记录仅需要扫描输入来源的链条。

## 10. 隐私

传统的金融模式通过限制参与者和可信任第三方的信息来维护一定程度的隐私。广播所有交易的必要性排除了这种方法，但是隐私仍然可以通过限制公共密钥的所有者将他们的身份与其密钥关联来实现。公众可以看到某人正在向另一人发送金额，但不知道是谁。

> 公共密钥 -> 身份

一种附加的隐私层可以通过为每笔交易使用一对新的密钥来实现，以防止交易被链接到共同的所有者。即使这样，某些链接仍然是不可避免的。例如，当几个输入交易合并到一个输出交易中时，这表明它们的输入都是由同一个所有者控制的。风险是，如果一个公共密钥的所有者被泄露，链接可以暴露所有属于该所有者的其他交易。

## 11. 计算

我们考虑一个攻击者试图生成一个比诚实链条增长得更快的替代链条。即使他做到了，这也不会使系统对任意更改开放，例如凭空创造价值或拿走并非属于自己的钱。节点不会接受无效的交易作为支付，而且诚实的节点永远不会包含它们。攻击者只能尝试改变他自己花过的交易，以夺回最近的钱。

诚实的链条和攻击者链条之间的竞争可以描述为一个二项式随机游走。成功率p是诚实链条找到下一个区块的概率，而失败率q是攻击者链条找到下一个区块的概率。

```math
概率(攻击者追赶) = \sum_{k=0}^{\infty} C(n+k, k) * p^n * q^k
```

给出了q < p，攻击者赶上来的概率随着交易添加到诚实链条后而指数级下降。通过在交易后等待更多区块，收款人验证其交易的可能性会呈指数级下降。

> **攻击者赶上来的概率:**

```math
p = 诚实链条找到下一个区块的概率
q = 攻击者链条找到下一个区块的概率
qa = 攻击者份额的CPU算力
qz = P(攻击者在 z 块后追上)
```

假设攻击者落后 z 个区块，他需要追上 z 个区块，同时诚实的链条仍然落后。

两个块之间的期望间隔是 λ = 1/p
攻击者发现一个块的期望时间是 1/q
攻击者追上来的概率是当攻击者的进度（即他在追赶诚实链条所需的区块数量）减去诚实链条的进度（即他们在追赶攻击者所需的区块数量）等于 z 时，也就是当他们的位置之差等于 z 时。

这是经典的赌徒破产问题。假设一个赌徒从 z 的赤字开始，进行无限次尝试，每一次成功的概率是 p，每一次失败的概率是 q。成功的补偿是 1，失败的惩罚是 1。问的是，赌徒是否最终能达到 0 的概率是多少？

赌场破产问题的概率为 q/p，如果 q <= p。
这里攻击者试图追赶，而不是破产。攻击者开始时落后 z，他们需要在诚实链条增长 k 个区块之前，增加 z 个区块。
如果 q > p, 攻击者迟早会追上。
如果 q <= p, 攻击者落后越多，追上的概率越低。
攻击者在诚实链条增长 k 个区块之前，追上 z 个区块的概率为:

```math
P(追上 | 落后 z) = (q/p)^z
```

考虑攻击者已经落后几个区块，并且希望计算在他们重新开始工作后赶上来的概率。诚实的链条每生成一个新区块，攻击者就会落后一个区块。攻击者每找到一个新区块，就可以减小一个区块的落后。

设 qz 是攻击者从落后 z 个区块追上来的概率。

```math
qz = 0  \text{ if } q >= p
qz = 1  \text{ if } q < p
```

qz 是攻击者找到下一个区块（概率 q）并将其差距缩小到 z-1 的概率，加上诚实的链条找到下一个区块（概率 p）并将其差距增加到 z+1 的概率。

```math
qz = q * q(z-1) + p * q(z+1)
```

加上边界条件 q0 = 1 和 qinfinity = 0。
这是一个线性递推关系。特征方程是：

```math
p * r^2 - r + q = 0
```

根是：

```math
r = [1 \pm \sqrt{1 - 4pq}] / 2p
  = [1 \pm \sqrt{1 - 4p(1-p)}] / 2p
  = [1 \pm \sqrt{(1-2p)^2}] / 2p
  = [1 \pm (1-2p)] / 2p
```

所以根是 r1 = 1 和 r2 = q/p。
一般解是 qz = A * 1^z + B * (q/p)^z。
使用边界条件：
q0 = 1 = A + B
qinfinity = 0 = A + B * infinity (仅当 q/p < 1 时才满足 0，即 q < p)

```math
0 = A + 0   => A = 0
```

如果 A=0, q0 = 1 = B。所以 B = 1。
最终解是 qz = (q/p)^z。

**Python 代码:**

```python
from math import exp, log, sqrt

def attacker_success_probability(q, z):
    # q: 攻击者算力份额
    # z: 攻击者落后区块数
    p = 1.0 - q
    if p <= q:
        return 1.0
    else:
        # 使用赌徒破产理论的精确解
        return (q/p)**z

# 测试不同 q 和 z 值
print("Probability of attacker success:")
print(f"q=0.1, z=0: {attacker_success_probability(0.1, 0):.6f}") # Should be 1
print(f"q=0.1, z=1: {attacker_success_probability(0.1, 1):.6f}")
print(f"q=0.1, z=2: {attacker_success_probability(0.1, 2):.6f}")
print(f"q=0.1, z=5: {attacker_success_probability(0.1, 5):.6f}")
print(f"q=0.1, z=10: {attacker_success_probability(0.1, 10):.6f}")
print(f"q=0.1, z=20: {attacker_success_probability(0.1, 20):.6f}")

print(f"q=0.3, z=0: {attacker_success_probability(0.3, 0):.6f}")
print(f"q=0.3, z=1: {attacker_success_probability(0.3, 1):.6f}")
print(f"q=0.3, z=5: {attacker_success_probability(0.3, 5):.6f}")
print(f"q=0.3, z=10: {attacker_success_probability(0.3, 10):.6f}")
print(f"q=0.3, z=20: {attacker_success_probability(0.3, 20):.6f}")

print(f"q=0.5, z=0: {attacker_success_probability(0.5, 0):.6f}") # Should be 1
print(f"q=0.5, z=1: {attacker_success_probability(0.5, 1):.6f}")
print(f"q=0.5, z=5: {attacker_success_probability(0.5, 5):.6f}")

print(f"q=0.6, z=0: {attacker_success_probability(0.6, 0):.6f}") # Should be 1
print(f"q=0.6, z=1: {attacker_success_probability(0.6, 1):.6f}")
print(f"q=0.6, z=5: {attacker_success_probability(0.6, 5):.6f}")
```

对于给定的收款人，交易发生后，他不知道攻击者占用了多少计算能力，但假定诚实节点控制着大部分CPU功率，那么随着每次添加新区块，交易就越来越不可能被推翻。

## 12. 结论

我们提出了一种新的电子现金系统，它不依赖于信任。我们从通常的数字签名币构建，通过加入一个点对点网络来添加解决双重支付问题的方案，该网络使用工作量证明来哈希交易的公共历史记录，形成一个除了重新进行攻击者大部分CPU计算力之外无法更改的记录。只要诚实的节点控制着大部分CPU计算力，他们就会生成最长的链条，并领先于攻击者。这个系统只需要很少的结构。消息以最佳方式广播，节点可以随时离开和重新加入网络，接受最长的工作量证明链条作为他们在离开期间发生事情的证明。节点根据他们的CPU计算能力投票，通过扩展接受他们的有效区块来表示接受。

## 参考文献

[1] W.戴，"b-money"，[http://www.weidai.com/bmoney.txt](http://www.weidai.com/bmoney.txt)，1998年。
[2] S. 哈伯和 W.S. 斯托内塔，"如何在数字文档上加盖时间戳"，Journal of Cryptology，第3卷，第2期，第99-111页，1991年。
[3] A. 巴克，"Hashcash - Anti-Spamming Applications"，2002年。[http://www.hashcash.org/papers/hashcash.pdf](http://www.hashcash.org/papers/hashcash.pdf)
[4] R.C. 梅克尔，"加密授权和非交互式身份证明"，IEEE国际信息论研讨会论文集，第318-321页，1979年。
[5] D. 贝尔曼，《编程加密的实用指南》，Wiley，1996年。 

## 补充阅读
1.https://zhuanlan.zhihu.com/p/25039679